E: factor       default $$ = $1 
 | E ADD factor { $$ = $1 + $3; }
 | E SUB factor { $$ = $1 - $3; }
 ;

%token NUMBER
%token ADD SUB MUL DIV POW
%token EOL
makeRPN: /* nothing */
 | makeRPN E EOL { printf("= %d\n", $2); } 
 ;

E: T Etail
  ;
 
F: (E) 
 | NUMBER { $$ = $1 + $3; }
 ;
 
ETail: EOL
 | ADD factor { $$ = $1 + $3; }
 | SUB factor { $$ = $1 - $3; }
 ;
 
E: factor
 | E ADD factor { $$ = $1 + $3; }
 | E SUB factor { $$ = $1 - $3; }
 ;
%%


number    [0-9]+
E  [{T} {ETail}]
F  [("("{E}")") | {number}]
ETail [( ("-" {ETail})  | ("+" {ETail}) )?]
T	[{N} {Ttail}]
Ttail	[(("*" {N} {Ttail}) | ("/" {N} {Ttail}))?]
N	[{F} {NTail}]
NTail	[("^" {N})?]



1 + 2 + 3 * 4 + 3

Num + Num + (Num * Num) + Num

typedef struct ExpTreeNode {
  TokenType tt;
  Token t;
  ExpTree left;
  ExpTree right;
} ExpTreeNode;

/* creates a new node for an expression tree */
ExpTree newExpTreeNode(TokenType tt, Token t, ExpTree tL, ExpTree tR) {
  ExpTree new = malloc(sizeof(ExpTreeNode));
  assert (new!=NULL);
  new->tt = tt;
  new->t = t;
  new->left = tL;
  new->right = tR;
  return new;
}
